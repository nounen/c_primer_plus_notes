#### 3.4.1 int类型
* C语言中的整数类型可表示不同的取值范围和正负值

* int类型是有符号整型，即int类型的值必须是整数，可以是 *正整数、负整数或零*

* 一般而言，储存一个int要占用一个机器字长。
    * 因此，早期的16 **位** IBM PC兼容机使用16位来储存一个int值，其取值范围（即int值的取值范围）是-32768～32767。

    * 目前的个人计算机一般是64位，因此用64位储存一个int值.

##### 1.声明int变量
```
int erns;
int hogs, cows, goats;
```

* 第2种途径是，通过函数（如，`scanf()`）获得值


##### 2.初始化变量
* *初始化（initialize）* 变量就是为变量赋一个初始值

* int dogs, cats = 94; // 有效，但是这种格式很 *糟糕*
    * 以上示例的最后一行，只初始化了cats，并未初始化dogs。这种写法很容易让人误认为dogs也被初始化为94

* 简而言之，声明为变量创建和标记存储空间，并为其指定初始值:
    * ![图3.4 定义并初始化变量](images/Screenshot_2017-10-30_22-13-17.png)


##### 3.int类型常量
* 上面示例中出现的整数（21、32、14和94）都是 **整型常量** 或 **整型字面量**

* C语言把 *大多数整型常量* 视为int类型，但是非常大的整数除外


##### 4.打印int值
* 可以使用 `printf()` 函数打印int类型的值
    * `%d` 指明了在一行中打印整数的位置

* 程序清单3.2 print1.c程序
```c
#include <stdio.h>

int main(void)
{
    int ten = 10;
    int two = 2;

    printf("Doing it right: \n");
    printf("%d munis %d is %d\n",ten, 2, ten - two);

    printf("Doing is wrong:");
    printf("%d minus %d is %d\n", ten); // 遗漏了两个参数 -- gcc 编译的时候会报　warning　（语法检测工具也能检查出来）

    return 0;
}
```

* 在第二行输出中，第1个%d对应ten的值，但是由于没有给后两个%d提供任何值，所以打印出的值是 *内存中的任意值*
    * 读者在运行该程序时显示的这两个数值会与输出示例中的数值不同，因为内存中储存的数据不同，而且编译器管理内存的位置也不同

    * 你可能会抱怨编译器为何不能捕获这种明显的错误，但实际上问题出在 printf()不寻常的设计。

    * 大部分函数都需要指定数目的参数，编译器会检查参数的数目是否正确


##### 5.八进制和十六进制 (REVIEW)
* C语言都假定整型常量是十进制数

* 然而，许多程序员很喜欢使用八进制和十六进制数。 *因为8和16都是2的幂*，而10却不是。

* 八进制和十六进制记数系统在表达与计算机相关的值时很方便
    * 例如，十进制数 65536 经常出现在 *16位* 机中，用 *十六进制* 表示正好是 10000

* 另外，十六进制数的每一位的数恰好由4位二进制数表示
    * 例如，十六进制数 3 是0011，十六进制数 5 是0101, 因此，十六进制数 35 的位组合（bit pattern）是 00110101, 十六进制数53的位组合是 01010011

    * 这种对应关系使得 十六进制 和 二进制 的转换非常方便

* 但是，计算机如何知道10000是十进制、十六进制还是二进制？
    * 在C语言中，用特定的前缀表示使用哪种进制。

    * `0x` 或 `0X` *前缀* 表示 **十六进制值**，所以 十进制数16 表示成 十六进制 是 0x10 或 0X10。

    * `0` *前缀* 表示 **八进制**。例如， 十进制数16 表示成 八进制 是020

* 要清楚，使用不同的进制数是为了方便，不会影响数被储存的方式
    * 也就是说，**无论** 把数字写成 16 、020 或 0x10，储存该数的方式都相同，因为计算机内部都以二进制进行编码


##### 6.显示八进制和十六进制
* 在C程序中，既可以使用和显示不同进制的数, 不同的进制要 *使用不同的转换说明*
    * 以十进制显示数字，使用 `%d`

    * 以八进制显示数字，使用 `%o`

    * 以十六进制显示数字，使用 `%x`

    * 要显示各进制数的前缀 0、0x 和 0X，必须分别使用 `%#o`、`%#x`、`%#X`

* 程序清单3.3 bases.c程序
```c
#include <stdio.h>

int main(void)
{
    int x = 100;

    // dec = 100; octal = 144; hex = 64
    printf("dec = %d; octal = %o; hex = %x \n", x, x, x);

    // dec = 100; octal = 0144; hex = 0x64
    printf("dec = %d; octal = %#o; hex = %#x \n", x, x, x);

    return 0;
}
```


#### 3.4.2 其他整数类型 (REVIEW)
* 有助于理解 mysql 字段的设计

* C语言提供3个附属关键字修饰基本整数类型：`short`、`long` 和 `unsigned`。应记住以下几点
    * `short int`类型（或者简写为short）占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。与int类似，short是 *有符号类型* 。

    * `long int` 或 `long` 占用的存储空间可能比int多，适用于较大数值的场合。与int类似，long是 *有符号类型*。

    * `long long int` 或 `long long`（C99标准加入）占用的储存空间可能比long多，适用于更大数值的场合。该类型至少占64位。与int类似，long long 是 *有符号类型*。

    * `unsigned int` 或 `unsigned` **只用于非负值** 的场合。这种类型与有符号类型表示的范围不同。
        * 例如，16位unsigned int允许的取值范围是0～65535，而不是-32768～32767。用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。

    * 在C90标准中，添加了unsigned long int或unsigned long和unsigned int或unsigned short类型。

    * C99标准又添加了unsigned long long int或unsigned long long。

    * 在任何有符号类型前面添加关键字 `signed`，可强调使用有符号类型的意图。例如，short、short int、signed short、signed short int都表示同一种类型。


##### 1.声明其他整数类型
* 略


##### 2.使用多种整数类型的原因 (REVIEW)
* 为什么说short类型“可能”比int类型占用的空间少，long类型“可能”比int类型占用的空间多？
    * 因为C语言 **只** 规定了 short 占用的存储空间不能多于 int，long 占用的存储空间不能少于 int

    * 这样规定是为了适应不同的机器。例如，过去的一台运行Windows 3的机器上，int 类型和 short 类型都占16位，long 类型占32位

    * 后来，Windows和苹果系统都使用16位储存short类型，32位储存int类型和long类型（使用32位可以表示的整数数值超过20亿）

    * 现在，计算机普遍使用 64位 处理器，为了储存64位的整数，才引入了long long类型

* 现在，个人计算机上最常见的设置是，long long占64位，long占32位，short占16位，int占16位或32位（依计算机的自然字长而定）


* C 标准对基本数据类型 **只** 规定了允许的最小大小。
    * 对于 16 位机，short 和 int 的最小取值范围是[−32767,32767]；

    * 对于32位机，long的最小取值范围是[−2147483647,2147483647]。

    * 对于unsigned short和unsigned int，最小取值范围是[0,65535]；

    * 对于unsigned long，最小取值范围是[0,4294967295]。

    * long long类型是为了支持64位的需求，最小取值范围是[−9223372036854775807,9223372036854775807]；

    * unsigned long long的最小取值范围是[0,18446744073709551615]。如果要开支票，这个数是一千八百亿亿（兆）六千七百四十四万亿零七百三十七亿零九百五十五万一千六百一十五。但是，谁会去数？


##### 3.long常量和long long常量
* 通常，程序代码中使用的数字（如，2345）都被储存为int类型: 超过就 int => long int => unsigned long => long long

* 有些情况下，需要编译器 **以long类型储存一个小数字**
    * 要把一个较小的常量作为long类型对待，可以在值的末尾加上 `l`（小写的L）或 `L` 后缀。

    * 使用L后缀更好，因为l看上去和数字1很像。

    * l或L后缀也可用于八进制和十六进制整数，如020L和0x10L


##### 整数溢出
* toobig.c-- 超出系统允许的最大int值
```c
#include <stdio.h>

int main(void)
{
    int i = 2147483647;

    unsigned int j = 4294967295;

    // 2147483647 -2147483648 -2147483647
    printf("%d %d %d\n", i, i+1, i+2);

    // 4294967295 0 1
    printf("%u %u %u\n", j, j+1, j+2);

    return 0;
}
```

* 可以把无符号整数j看作是汽车的里程表。当达到它能表示的最大值时，会重新从起始点开始


##### 4.打印short、long、long long和unsigned类型 (REVIEW)
* 打印 unsigned int 类型的值，使用 `%u` 转换说明；

* 打印 long 类型的值，使用 `%ld` 转换说明

* 如果系统中int和long的大小相同，使用%d就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作  

* 在 x 和 o 前面可以使用 l 前缀，`%lx` 表示以十六进制格式打印 long 类型整数`，%lo` 表示以八进制格式打印long类型整数

* 对于 short 类型，可以使用 h 前缀。`%hd` 表示以十进制显示 short 类型的整数，`%ho` 表示以八进制显示short类型的整数

* h 和 l 前缀都可以和 u 一起使用，用于表示无符号类型

* 程序清单3.4 print2.c程序
```c
#include <stdio.h>

int main(void)
{
    unsigned int un = 3000000000; // int为32位和short为16位的系统
    short end = 200;
    long big = 65537;
    long long verybig = 12345678908642;

    // un = 3000000000 and not -1294967296
    printf("un = %u and not %d\n", un, un);

    // end = 200 and 200
    printf("end = %hd and %d\n", end, end);

    // end = 65537 and not 65537 (PS: 原书是 big = 65537 and not 1， 因为是在 64位 计算机系统)
    printf("end = %ld and not %d\n", big, big);

    // verybig = 12345678908642 and not 12345678908642 （PS： 原书是 verybig= 12345678908642 and not 1942899938）
    printf("verybig = %lld and not %ld\n", verybig, verybig);

    return 0;
}
```

* **REVIEW**: 从书本里的输出结果（32位系统） 与 实际操作输出结果（64 位系统）对比， 充分体现了操作系统的位数对各种 int 的影响

* 第 1 行输出，对于无符号变量 un，使用 %d 会生成负值！其原因是，*无符号值 3000000000 和有符号值−129496296 在系统内存中的内部表示完全相同*
    * 因此，如果告诉printf()该数是无符号数，它打印一个值；如果告诉它该数是有符号数，它将打印另一个值

* 第2行输出，对于 short 类型的变量 end，在printf()中无论指定以short类型（%hd）还是int类型（%d）打印，打印出来的值都相同
    * 这是因为在给函数传递参数时，C编译器把short类型的值自动转换成int类型的值

    * 你可能会提出疑问：为什么要进行转换？h修饰符有什么用？
        * 第1个问题的答案是， *int类型被认为是计算机处理整数类型时最高效的类型*。因此，在short和int类型的大小不同的计算机中，用int类型的参数传递速度更快

        * 第2个问题的答案是，使用 h 修饰符可以显示较大整数被截断成 short 类型值的情况

* 第 3 行输出就演示了这种情况。把 65537 以二进制格式写成一个 **32 位** (32 位的系统)数是 00000000000000010000000000000001。使用 %hd，printf()只会查看后 *16 位*，所以显示的值是 1。

* 与此类似，输出的最后一行先显示了verybig的完整值，然后由于使用了%ld，printf()只显示了储存在后32位的值。


#### 3.4.3 使用字符：char类型
* char类型用于储存字符（如，字母或标点符号）
    * 但是从技术层面看，char是整数类型, 因为char类型实际上储存的是整数而不是字符。

* 计算机使用数字编码来处理字符，即用特定的整数表示特定的字符。美国最常用的编码是ASCII编码，本书也使用此编码
    * 例如，在ASCII码中，整数65代表大写字母A

    * 另外，其他国家的计算机系统可能使用完全不同的编码

* 标准ASCII码的范围是 **0～127**，只需 7位二进制数 即可表示
    * 通常，char类型被定义为8位的存储单元，因此容纳标准ASCII码绰绰有余

* 许多字符集都超过了127，甚至多于255。例如，日本汉字（kanji）字符集。
    * 商用的统一码（**Unicode**）创建了一个能表示世界范围内多种字符集的系统，目前包含的字符已超过110000个。

    * 国际标准化组织（ISO）和国际电工技术委员会（IEC）为字符集开发了ISO/IEC 10646标准。统一码标准也与ISO/IEC 10646标准兼容。

* C语言把 **1字节** 定义为 **char类型占用的位（bit）数**，因此无论是16位还是32位系统，都可以使用char类型。

##### 1.声明char类型变量
* `char response; char itable, latan;`

##### 2.字符常量和初始化
* `char grade = 'A';`
    * 在C语言中，用 **单引号** 括起来的单个字符被称为 *字符常量（character constant）*

* C语言将字符常量视为int类型而非char类型。例如，在int为32位、char为8位的ASCII系统中，有下面的代码：
    * `char grade = 'B';` 本来'B'对应的数值66储存在32位的存储单元中，现在却可以储存在8位的存储单元中（grade）

    * （TODO: 没理解）利用用字符常量的这种特性，可以定义一个字符常量'FATE' （PS： 但是字符产量没办法这么定义啊, 这明明是字符串不是字符），即把4个独立的8位ASCII码储存在一个32位存储单元中。如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。因此，grade的值是'E'。
        * 表示配合 char_test.c 就理解了：
        ```c
        #include <stdio.h>

        int main(void)
        {
            char grade = 'FATE'; // 所以这样定义是没问题的， 只报了 warning

            // E。 实际输出是最后一个字符
            // 即把4个独立的8位ASCII码储存在一个32位存储单元中。如果把这样的字符常量赋给char类型变量grade，只有最后8位有效
            printf("%c\n", grade);

            return 0;
        }
        ```

##### 3.非打印字符
* 单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些ASCII字符打印不出来。
    * 例如，一些代表行为的字符（如，退格、换行、终端响铃或蜂鸣）。C语言提供了3种方法表示这些字符。

* *第1种方法* 前面介绍过——使用ASCII码。例如，蜂鸣字符的ASCII值是7，因此可以这样写： `char beep = 7;`

* *第2种方法* 是，使用特殊的符号序列表示一些特殊的字符。这些符号序列叫作转义序列（escape sequence）
    * `char nerf = '\n';` // 稍后打印变量nerf的效果是，在打印机或屏幕上另起一行。

    * ![表3.2 转义序列](images/Screenshot_2017-11-01_23-05-54.png)

    * 这些转义序列字符不一定在所有的显示设备上都起作用。例如，换页符和垂直制表符在PC屏幕上会生成奇怪的符号，光标并不会移动
        * **只有** 将其输出到 **打印机** 上时才会产生效果。

* 从C90开始，不仅可以用十进制、八进制形式表示字符常量，C语言还提供了第3种选择——用十六进制形式表示字符常量，即反斜杠后面跟一个x或X，再加上1～3位十六进制数字
    * ![图3.5 int系列类型的常量写法示例](images/Screenshot_2017-11-01_23-11-33.png)

* 何时使用ASCII码？何时使用转义序列？
    * 如果要在转义序列（假设使用'\f'）和ASCII码（'\014'）之间选择，请选择前者（即'\f'）。这样的写法不仅更好记，而且可移植性更高。'\f'在不使用ASCII码的系统中，仍然有效

##### 4.打印字符
* printf() 函数用 `%c` 指明待打印的字符
    * 如果用%d转换说明打印 char类型变量的值，打印的是一个整数

* 程序清单3.5 charcode.c程序:
```c
#include <stdio.h>

int main(void)
{
    char ch;

    printf("please enter a chatacter\n");

    scanf("%c\n", &ch); // 用户输入字符

    printf("the code for %c is %d.\n", ch, ch);

    return 0;
}
```

* 注意，printf()函数中的转换说明决定了数据的显示方式，而不是数据的储存方式（见图3.6）。
    * ![图3.6 数据显示和数据存储](images/Screenshot_2017-11-01_23-20-38.png)


##### 5.有符号还是无符号
* 有些C编译器把char实现为有符号类型，这意味着char可表示的范围是-128～127。

* 而有些C编译器把char实现为无符号类型，那么char可表示的范围是0～255。

* 请查阅相应的编译器手册，确定正在使用的编译器如何实现char类型。或者，可以查阅 *limits.h头 文件*

* 根据C90标准，C语言允许在关键字 `char` 前面使用 `signed` 或 `unsigned` (这样就解决了不同编译器的问题)



#### 3.4.4 `_Bool`类型
* C99标准添加了`_Bool`类型，用于表示布尔值，即逻辑值 `true` 和 `false`。

* 因为C语言用值 1 表示 true，值 0 表示 false，所以_Bool类型实际上也是一种整数类型。

* 但 *原则上* 它仅占用1位存储空间，因为对 0 和 1 而言，1位的存储空间足够了。



#### 3.4.5 可移植类型：stdint.h 和 inttypes.h
* C99 新增了两个头文件 stdint.h 和 inttypes.h ，**以确保C语言的类型在各系统中的功能相同**

* 程序清单3.6 altnames.c程序
```c
#include <stdio.h>
#include <inttypes.h> // 支持可移植类型

int main(void)
{
    int32_t me32; // me32是一个32位有符号整型变量
    me32 = 45933945;

    printf("First, assume int32_t is int：");
    printf("me32 = %d\n", me32);

    printf("Next, let's not make any assumptions.\n");
    printf("Instead, use a \"macto\" from inttypes.h: ");

    // 参数PRId32被定义在inttypes.h中的"d"替换，因而这条语句等价于：
    // printf("me16 = %" "d" "\n", me16);
    printf("me32 = %" PRId32 "\n", me32);

    return 0;
}
```

* TODO: 没有细看， 暂时略过。 整型已经够多了！



#### 3.4.6 float、double 和 long double
* 面向金融和数学的程序经常使用浮点数。C语言中的浮点类型有 float、double 和 long double类型

* ![表3.3 记数法示例](images/Screenshot_2017-11-03_22-29-23.png)
    * 第1列是一般记数法；

    * 第2列是科学记数法；

    * 第3列是指数记数法（或称为e记数法），这是科学记数法在计算机中的写法，e后面的数字代表10的指数。

* **C标准规定**，**float** 类型必须至少能表示 6位 有效数字，且取值范围至少是 10的-37次方～10的+37次方。(REVIEW)
    * 前一项规定指 float 类型 **必须至少精确表示** 小数点后的6位有效数字，如 33.333333。

    * 后一项规定用于方便地表示诸如太阳质量（2.0e30千克）、一个质子的电荷量（1.6e-19库仑）或国家债务之类的数字

    * 通常，系统储存一个浮点数要占用 **32位**。其中 *8位* 用于表示 **指数的值** 和 **符号**，剩下 24位 用于表示 **非指数** 部分（也叫作尾数或有效数）及其符号。

* C语言提供的另一种浮点类型是 **double**（意为双精度）。
    * double类型 和 float类型 的最小取值范围相同，但至少必须能表示 10位 有效数字。

    * 一般情况下，double 占用 **64位** 而不是32位

    * 一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。

    * 另一些系统把其中的一些位分配给指数部分，以容纳更大的指数，从而增加了可表示数的范围。

    * 无论哪种方法，double类型的值至少有13位有效数字，超过了标准的最低位数规定。

* C语言的第3种浮点类型是 **long double**，以满足比double类型更高的精度要求。不过，C只保证long double类型至少与double类型的精度相同。

##### 1.声明浮点型变量
```
float　noah,　jonah;
double　trouble;
float　planck　=　6.63e-34;
long　double　gnp;
```

##### 2.浮点型常量 (数字 + 指数)
* 浮点型常量的基本形式是：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数表示10的指数:
```
-1.56E+12
2.87e-3
```

* 不要在浮点型常量中间加空格

* *默认情况下*，编译器假定浮点型常量是double类型的精度。
    * 例如，假设some是float类型的变量，编写下面的语句：
        * `some = 4.0 * 2.0;`

        * 通常，4.0和2.0被储存为64位的 double 类型，使用双精度进行乘法运算，然后将乘积截断成float类型的宽度。

        * 这样做虽然计算精度更高，但是会减慢程序的运行速度。

* 在浮点数后面加上 **f** 或 **F** 后缀可覆盖默认设置，编译器会将浮点型常量看作 float 类型，如2.3f和9.11E9F

* 使用 **l** 或 **L** 后缀使得数字成为 long double 类型，如54.3l和4.32L

* C99 标准添加了一种新的浮点型常量格式——用十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和E，用2的幂代替10的幂（即，p计数法）。如: 0xa.1fp10

##### 3.打印浮点值
* printf() 函数使用 `%f` 转换说明打印十进制记数法的 float 和 double 类型浮点数，用 `%e` 打印指数记数法的浮点数

* 程序清单3.7 showf_pt.c 程序
```c
#include <stdio.h>

int main(void)
{
    float aboat = 32000.0;
    double abet = 2.14e9;
    long double dip = 5.32e-5;

    // 32000.000000 can be written 3.200000e+04
    printf("%f can be written %e\n", aboat, aboat);

    // 下一行要求编译器支持C99或其中的相关特性
    // And it's 0x1.f4p+14 in hexadecimal, powers of 2 notation
    printf("And it's %a in hexadecimal, powers of 2 notation\n", aboat);

    // 2140000000.000000 can be written 2.140000e+09
    printf("%f can be written %e\n", abet, abet);

    // 0.000053 can be written 5.320000e-05
    printf("%Lf can be written %Le\n", dip, dip);

    return 0;
}
```

##### 4.浮点值的上溢和下溢
* 当计算导致数字过大，超过当前类型能表达的范围时，就会发生 **上溢**。这种行为在过去是未定义的，不过现在C语言规定，在这种情况下会赋一个表示无穷大的特定值，而且 printf() 显示该值为 `inf` 或 `infinity`（或者具有无穷含义的其他内容）。

* 当除以一个很小的数时，情况更为复杂。
    * >float类型的数以指数和尾数部分来储存。存在这样一个数，它的指数部分是最小值，即由全部可用位表示的最小尾数值。该数字是float类型能用全部精度表示的最小数字。现在把它除以 2。通常，这个操作会减小指数部分，但是假设的情况中，指数已经是最小值了。所以计算机只好把尾数部分的位向右移，空出第 1 个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有4位有效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫作 **下溢**（underflow）。C语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值。因此，把最小的正浮点数除以 2将得到一个低于正常的值。如果除以一个非常大的值，会导致所有的位 **都为0**。现在，C库已提供了用于检查计算是否会产生低于正常值的函数。

##### 浮点数舍入错误
* floaterr.c--演示舍入错误
```c
#include <stdio.h>

int main(void)
{
    float a, b;

    b = 2.0e20 + 1.0;
    a = b - 2.0e20;

    // 0.000000 linux的老式 gcc下
    // 4008175468544.000000 实际是这样
    printf("%f \n", a);

    return 0;
}
```

* > 得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运算。2.0e20是 2后面有20个0。如果把该数加1，那么发生变化的是第21位。要正确运算，程序至少要储存21位数字。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。另一方面，如果把2.0e20改成2.0e4，计算结果就没问题。因为2.0e4加1只需改变第5位上的数字，float类型的精度足够进行这样的计算。

##### 浮点数表示法
* > 上一个方框中列出了由于计算机使用的系统不同，一个程序有不同的输出。原因是，根据前面介绍的知识，实现浮点数表示法的方法有多种。为了尽可能地统一实现，电子和电气工程师协会（IEEE）为浮点数计算和表示法开发了一套标准。现在，许多硬件浮点单元都采用该标准。2011年，该标准被ISO/IEC/IEEE 60559:2011标准收录。该标准作为C99和C11的可选项，符合硬件要求的平台可开启。floaterr.c程序的第3个输出示例即是支持该浮点标准的系统显示的结果。支持C标准的编译器还包含捕获异常问题的工具。详见附录B.5，参考资料V。



#### 3.4.7 复数和虚数类型
* TODO：略

* 许多科学和工程计算都要用到复数和虚数。C99 标准支持复数类型和虚数类型，但是有所保留

* 简而言之，C语言有3种复数类型：`float_Complex`、`double_Complex` 和 `long double _Complex`



#### 3.4.8 其他类型
* C语言还有一些从基本类型衍生的其他类型，包括 *数组、指针、结构和联合*

* 章的程序示例中已经用到了 *指针*〔指针（pointer）指向变量或其他数据对象位置〕
    * 例如，在 `scanf()` 函数中用到的前缀 `&`，便创建了一个指针，告诉 `scanf()` 把数据放在何处

##### 小结：基本数据类型
* 关键字：基本数据类型由11个关键字组成：`int、long、short、unsigned、char、float、double、signed、_Bool、_Complex和_Imaginary`

* 有符号整型：`int, short, short int, long, long int, long long, long long int`

* 无符号整型： `unsignedint, unsigned long, unsigned short, unsigned`

* 字符类型： `char`

* 布尔类型： `true， false`

* 实浮点类型： `float, double, long long`

* 复数和虚数浮点数： `float _Complex， double _Complex， long double _Complex， float _Imaginary， double _Imaginary， long long _Imaginary`



#### 3.4.9 类型大小
* 程序清单3.8 typesize.c程序:

* `sizeof` 是C语言的内置运算符，以 **字节** 为单位给出指定类型的大小

```c
#include <stdio.h>

int main(void)
{
    // sizeof 是C语言的内置运算符，以字节为单位给出指定类型的大小。
    // C99和C11提供 %zd 转换说明匹配 sizeof 的返回类型

    // 4 bytes
    printf("Type int has a size of %zd bytes.\n", sizeof(int));

    // 1 bytes
    printf("Type char has a size of %zd bytes.\n", sizeof(char));

    // 8 bytes
    printf("Type long has a size of %zd bytes.\n", sizeof(long));

    // 8 bytes
    printf("Type long long has a size of %zd bytes.\n", sizeof(long long));

    // 8 bytes
    printf("Type double has a size of %zd bytes.\n", sizeof(double));

    // 16 bytes
    printf("Type long double has a size of %zd bytes.\n", sizeof(long double));

    return 0;
}
```
